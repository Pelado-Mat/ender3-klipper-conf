=============== Log rollover at Sun Jun  9 03:17:39 2024 ===============
Starting Klippy...
Args: ['/home/m/klipper/klippy/klippy.py', '/home/m/printer_data/config/printer.cfg', '-l', '/home/m/printer_data/logs/klippy.log', '-I', '/home/m/printer_data/comms/klippy.serial', '-a', '/home/m/printer_data/comms/klippy.sock']
Git version: 'v0.12.0-178-g7e8c7f46-dirty'
Untracked files: klippy/extras/fcm.py
Branch: master
Remote: origin
Tracked URL: https://github.com/Klipper3d/klipper.git
CPU: 4 core ARMv7 Processor rev 4 (v7l)
Python: '3.9.2 (default, Mar 12 2021, 04:06:34) \n[GCC 10.2.1 20210110]'
Start printer at Sun Jun  9 03:17:41 2024 (1717917461.4 45.7)
===== Config file =====
[virtual_sdcard]
path = /home/m/printer_data/gcodes
on_error_gcode = CANCEL_PRINT

[pause_resume]

[display_status]

[respond]

[gcode_macro CANCEL_PRINT]
description = Cancel the actual running print
rename_existing = CANCEL_PRINT_BASE
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set allow_park = client.park_at_cancel|default(false)|lower == 'true' %}
	{% set retract = client.cancel_retract|default(5.0)|abs %}
	
	{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)
	else "X=" ~ client.park_at_cancel_x %}
	{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)
	else "Y=" ~ client.park_at_cancel_y %}
	{% set custom_park = park_x|length > 0 or park_y|length > 0 %}
	
	
	{% if printer['gcode_macro RESUME'].restore_idle_timeout > 0 %}
	SET_IDLE_TIMEOUT TIMEOUT={printer['gcode_macro RESUME'].restore_idle_timeout}
	{% endif %}
	{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}
	_CLIENT_RETRACT LENGTH={retract}
	TURN_OFF_HEATERS
	M106 S0
	{client.user_cancel_macro|default("")}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False
	
	SET_PAUSE_NEXT_LAYER ENABLE=0
	SET_PAUSE_AT_LAYER ENABLE=0 LAYER=0
	CANCEL_PRINT_BASE

[gcode_macro PAUSE]
description = Pause the actual running print
rename_existing = PAUSE_BASE
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set idle_timeout = client.idle_timeout|default(0) %}
	{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != '' else 0 %}
	{% set restore = False if printer.toolhead.extruder == ''
	else True  if params.RESTORE|default(1)|int == 1 else False %}
	
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{'restore': restore, 'temp': temp}}"
	
	{% if idle_timeout > 0 %}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}
	SET_IDLE_TIMEOUT TIMEOUT={idle_timeout}
	{% endif %}
	PAUSE_BASE
	{client.user_pause_macro|default("")}
	_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}

[gcode_macro RESUME]
description = Resume the actual running print
rename_existing = RESUME_BASE
variable_last_extruder_temp = {'restore': False, 'temp': 0}
variable_restore_idle_timeout = 0
variable_idle_state = False
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set sp_move = client.speed_move|default(velocity) %}
	{% set runout_resume = True if client.runout_sensor|default("") == ""
	else True if not printer[client.runout_sensor].enabled
	else printer[client.runout_sensor].filament_detected %}
	{% set can_extrude = True if printer.toolhead.extruder == ''
	else printer[printer.toolhead.extruder].can_extrude %}
	{% set do_resume = False %}
	{% set prompt_txt = [] %}
	
	
	{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False
	{% if last_extruder_temp.restore %}
	
	RESPOND TYPE=echo MSG='{"Restoring \"%s\" temperature to %3.1f\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }'
	M109 S{last_extruder_temp.temp}
	{% set do_resume = True %}
	{% elif can_extrude %}
	{% set do_resume = True %}
	{% else %}
	RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}'
	{% set _d = prompt_txt.append("\"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder) %}
	{% endif %}
	
	{% elif can_extrude %}
	{% set do_resume = True %}
	{% else %}
	RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}'
	{% set _d = prompt_txt.append("\"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder) %}
	{% endif %}
	{% if runout_resume %}
	{% if do_resume %}
	{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}
	{client.user_resume_macro|default("")}
	_CLIENT_EXTRUDE
	RESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}
	{% endif %}
	{% else %}
	RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}'
	{% set _d = prompt_txt.append("\"%s\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]) %}
	{% endif %}
	
	{% if not (runout_resume and do_resume) %}
	RESPOND TYPE=command MSG="action:prompt_begin RESUME aborted !!!"
	{% for element in prompt_txt %}
	RESPOND TYPE=command MSG='{"action:prompt_text %s" % element}'
	{% endfor %}
	RESPOND TYPE=command MSG="action:prompt_footer_button Ok|RESPOND TYPE=command MSG=action:prompt_end|info"
	RESPOND TYPE=command MSG="action:prompt_show"
	{% endif %}

[gcode_macro SET_PAUSE_NEXT_LAYER]
description = Enable a pause if the next layer is reached
gcode = 
	{% set pause_next_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer %}
	{% set ENABLE = params.ENABLE|default(1)|int != 0 %}
	{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ 'enable': ENABLE, 'call': MACRO }}"

[gcode_macro SET_PAUSE_AT_LAYER]
description = Enable/disable a pause if a given layer number is reached
gcode = 
	{% set pause_at_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer %}
	{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined
	else params.LAYER is defined %}
	{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}
	{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ 'enable': ENABLE, 'layer': LAYER, 'call': MACRO }}"

[gcode_macro SET_PRINT_STATS_INFO]
rename_existing = SET_PRINT_STATS_INFO_BASE
description = Overwrite, to get pause_next_layer and pause_at_layer feature
variable_pause_next_layer = { 'enable': False, 'call': "PAUSE" }
variable_pause_at_layer = { 'enable': False, 'layer': 0, 'call': "PAUSE" }
gcode = 
	{% if pause_next_layer.enable %}
	RESPOND TYPE=echo MSG='{"%s, forced by pause_next_layer" % pause_next_layer.call}'
	{pause_next_layer.call}
	SET_PAUSE_NEXT_LAYER ENABLE=0
	{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}
	RESPOND TYPE=echo MSG='{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}'
	{pause_at_layer.call}
	SET_PAUSE_AT_LAYER ENABLE=0
	{% endif %}
	SET_PRINT_STATS_INFO_BASE {rawparams}

[gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL]
description = Helper: park toolhead used in PAUSE and CANCEL_PRINT
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set use_custom     = client.use_custom_pos|default(false)|lower == 'true' %}
	{% set custom_park_x  = client.custom_park_x|default(0.0) %}
	{% set custom_park_y  = client.custom_park_y|default(0.0) %}
	{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}
	{% set sp_hop         = client.speed_hop|default(15) * 60 %}
	{% set sp_move        = client.speed_move|default(velocity) * 60 %}
	
	{% set origin    = printer.gcode_move.homing_origin %}
	{% set act       = printer.gcode_move.gcode_position %}
	{% set max       = printer.toolhead.axis_maximum %}
	{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}
	{% set round_bed = True if printer.configfile.settings.printer.kinematics is in ['delta','polar','rotary_delta','winch']
	else False %}
	
	{% set z_min = params.Z_MIN|default(0)|float %}
	{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}
	{% set x_park = params.X       if params.X is defined
	else custom_park_x  if use_custom
	else 0.0            if round_bed
	else (max.x - 5.0) %}
	{% set y_park = params.Y       if params.Y is defined
	else custom_park_y  if use_custom
	else (max.y - 5.0)  if round_bed and z_park < cone
	else 0.0            if round_bed
	else (max.y - 5.0) %}
	
	_CLIENT_RETRACT
	{% if "xyz" in printer.toolhead.homed_axes %}
	G90
	G1 Z{z_park} F{sp_hop}
	G1 X{x_park} Y{y_park} F{sp_move}
	{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}
	{% else %}
	RESPOND TYPE=echo MSG='Printer not homed'
	{% endif %}

[gcode_macro _CLIENT_EXTRUDE]
description = Extrudes, if the extruder is hot enough
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}
	{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}
	{% set absolute_extrude = printer.gcode_move.absolute_extrude %}
	
	{% if printer.toolhead.extruder != '' %}
	{% if printer[printer.toolhead.extruder].can_extrude %}
	{% if use_fw_retract %}
	{% if length < 0 %}
	G10
	{% else %}
	G11
	{% endif %}
	{% else %}
	M83
	G1 E{length} F{(speed|float|abs) * 60}
	{% if absolute_extrude %}
	M82
	{% endif %}
	{% endif %}
	{% else %}
	RESPOND TYPE=echo MSG='{"\"%s\" not hot enough" % printer.toolhead.extruder}'
	{% endif %}
	{% endif %}

[gcode_macro _CLIENT_RETRACT]
description = Retracts, if the extruder is hot enough
gcode = 
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}
	
	_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}

[gcode_macro _CLIENT_VARIABLE]
gcode = 

[gcode_macro PROBE_OUT]
gcode = 
	G90
	G1 X245 F4000
	G4 P300
	G1 Z15
	G1 X0

[gcode_macro PROBE_IN]
gcode = 
	G90
	G1 Z20
	G1 X245 F20000
	G1 Y-8
	G1 Z0
	G4 P300
	G1 X220 F6000
	G1 Z10
	G1 X0

[gcode_macro Accuracy_Test]
gcode = 
	PROBE_OUT
	G90
	G1 Y120 X120 F20000
	PROBE_ACCURACY
	PROBE_IN

[gcode_macro SCREWS_TILT_CALCULATE]
rename_existing = _SCREWS_TILT_CALCULATE
gcode = 
	PROBE_OUT
	_SCREWS_TILT_CALCULATE
	PROBE_IN

[gcode_macro Z_TILT_ADJUST]
rename_existing = _Z_TILT_ADJUST
gcode = 
	PROBE_OUT
	_Z_TILT_ADJUST
	PROBE_IN

[gcode_macro CLEAN_NOZZLE]
variable_start_x = 185
variable_start_y = -15
variable_fuzz_amount = 2
variable_start_z = 3
variable_wipe_dist = 45
variable_wipe_qty = 6
variable_wipe_spd = 400
variable_raise_distance = 10
variable_clear_distance = 10
gcode = 
	{% if "xyz" in printer.toolhead.homed_axes %}
	{% set fuzz_range = range ( ( ( (fuzz_amount * 100) | int + 1 ) * -1 ), (fuzz_amount * 100) | int + 1) %}
	{% set adapted_y = start_y + (fuzz_range | random / 100.0) %}
	
	SAVE_GCODE_STATE NAME=clean_nozzle
	G90
	
	G1 X{start_x} Y{adapted_y} F6000
	G1 Z{start_z} F1500
	
	G1 E-2 F3000
	
	
	{% for wipes in range(1, (wipe_qty + 1)) %}
	G1 X{start_x + wipe_dist} F{wipe_spd * 60}
	G1 X{start_x} F{wipe_spd * 60}
	{% endfor %}
	
	G1 Z{raise_distance} F3000
	G1 Y{clear_distance} F6000
	SET_DISPLAY_TEXT MSG="Cleaned!"
	
	RESTORE_GCODE_STATE NAME=clean_nozzle
	{% else %}
	
	
	{ action_raise_error("Please home your axes!") }
	SET_DISPLAY_TEXT MSG="Please home first!"
	{% endif %}

[gcode_macro PRINT_START]
gcode = 
	
	{% set target_bed = params.BED|int %}
	{% set target_extruder = params.EXTRUDER|int %}
	{% set target_chamber = params.CHAMBER|default("40")|int %}
	{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}
	{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}
	M140 S{target_bed}
	M104 S150
	SET_SKEW XY=141.2,141.2,99.8
	
	
	BED_MESH_CLEAR
	
	SET_DISPLAY_TEXT MSG="Hotend: 150c"
	
	M190 S{target_bed}
	G28
	
	
	
	G90
	M82
	G1 X{x_wait} Y{y_wait} Z15 F9000
	M109 S150
	
	SET_DISPLAY_TEXT MSG="Bed mesh"
	bed_mesh_calibrate
	
	
	SET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"
	
	SMART_PARK
	M107
	M109 S{target_extruder}
	
	
	CLEAN_NOZZLE
	SET_DISPLAY_TEXT MSG="Printer goes brr"
	
	
	
	
	
	
	
	
	
	LINE_PURGE

[gcode_macro PRINT_END]
gcode = 
	SET_DISPLAY_TEXT MSG="Print Finished"
	
	M140 S0
	M104 S0
	M106 S0
	
	G91
	G1 X-2 Y-2 E-3 F300
	
	G1 Z10 F3000
	G90
	G0 Y170 X10
	
	M84
	FCM_NOTIFY MSG="Printing Done" TITLE="Ender3"
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=30

[gcode_macro _POWER_OFF_PRINTER]
gcode = 
	{action_call_remote_method("set_device_power",
	device="printer",
	state="off")}

[delayed_gcode POWER_OFF_PRINTER_CHECK]
gcode = 
	{% if printer.idle_timeout.state == "Idle" or printer.idle_timeout.state == "Ready" %}
	{% if printer.extruder.temperature < 50.0 and printer.heater_bed.temperature < 50.0 %}
	{% if printer.extruder.target == 0.0 and printer.heater_bed.target == 0.0 %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=0
	SET_DISPLAY_TEXT MSG="PowerOff Printer"
	_POWER_OFF_PRINTER
	{% else %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=2
	{% endif %}
	{% else %}
	{% if printer.idle_timeout.state == "Printing" %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=0
	{% else %}
	{% if printer.extruder.target == 0.0 and printer.heater_bed.target == 0.0 %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=2
	{% else %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=0
	{% endif %}
	{% endif %}
	{% endif %}
	{% endif %}

[gcode_macro ACTIVATE_POWER_OFF]
gcode = 
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK_ACT DURATION=60

[gcode_macro DEACTIVATE_POWER_OFF]
gcode = 
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK_ACT DURATION=0

[delayed_gcode POWER_OFF_PRINTER_CHECK_ACT]
gcode = 
	{% if printer.idle_timeout.state == "Idle" or printer.idle_timeout.state == "Ready" %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=30
	{% else %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK_ACT DURATION=60
	{% endif %}

[gcode_macro M600]
gcode = 
	
	PAUSE

[gcode_macro _bot_data]
variable_lapse_video_size = 0
variable_lapse_filename = 'None'
variable_lapse_path = 'None'
gcode = 
	M118 Setting bot lapse variables

[gcode_macro TEST_SPEED]
gcode = 
	
	{% set speed  = params.SPEED|default(printer.configfile.settings.printer.max_velocity)|int %}
	
	{% set iterations = params.ITERATIONS|default(5)|int %}
	
	{% set accel  = params.ACCEL|default(printer.configfile.settings.printer.max_accel)|int %}
	
	{% set bound = params.BOUND|default(20)|int %}
	
	{% set smallpatternsize = SMALLPATTERNSIZE|default(20)|int %}
	
	
	
	{% set x_min = printer.toolhead.axis_minimum.x + bound %}
	{% set x_max = printer.toolhead.axis_maximum.x - bound %}
	{% set y_min = printer.toolhead.axis_minimum.y + bound %}
	{% set y_max = printer.toolhead.axis_maximum.y - bound %}
	
	
	
	{% set x_center = (printer.toolhead.axis_minimum.x|float + printer.toolhead.axis_maximum.x|float ) / 2 %}
	{% set y_center = (printer.toolhead.axis_minimum.y|float + printer.toolhead.axis_maximum.y|float ) / 2 %}
	
	
	{% set x_center_min = x_center - (smallpatternsize/2) %}
	{% set x_center_max = x_center + (smallpatternsize/2) %}
	{% set y_center_min = y_center - (smallpatternsize/2) %}
	{% set y_center_max = y_center + (smallpatternsize/2) %}
	
	
	SAVE_GCODE_STATE NAME=TEST_SPEED
	
	
	{ action_respond_info("TEST_SPEED: starting %d iterations at speed %d, accel %d" % (iterations, speed, accel)) }
	
	
	M400
	G28
	
	{% if printer.configfile.settings.quad_gantry_level %}
	{% if printer.quad_gantry_level.applied == False %}
	QUAD_GANTRY_LEVEL
	G28 Z
	{% endif %}
	{% endif %}
	
	G90
	G1 X{printer.toolhead.axis_maximum.x-50} Y{printer.toolhead.axis_maximum.y-50} F{30*60}
	M400
	G28 X Y
	G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
	G4 P1000
	GET_POSITION
	
	
	G0 X{x_min} Y{y_min} Z{bound + 10} F{speed*60}
	
	
	SET_VELOCITY_LIMIT VELOCITY={speed} ACCEL={accel} ACCEL_TO_DECEL={accel / 2}
	
	{% for i in range(iterations) %}
	
	G0 X{x_min} Y{y_min} F{speed*60}
	G0 X{x_max} Y{y_max} F{speed*60}
	G0 X{x_min} Y{y_min} F{speed*60}
	G0 X{x_max} Y{y_min} F{speed*60}
	G0 X{x_min} Y{y_max} F{speed*60}
	G0 X{x_max} Y{y_min} F{speed*60}
	
	
	G0 X{x_min} Y{y_min} F{speed*60}
	G0 X{x_min} Y{y_max} F{speed*60}
	G0 X{x_max} Y{y_max} F{speed*60}
	G0 X{x_max} Y{y_min} F{speed*60}
	
	
	G0 X{x_center_min} Y{y_center_min} F{speed*60}
	G0 X{x_center_max} Y{y_center_max} F{speed*60}
	G0 X{x_center_min} Y{y_center_min} F{speed*60}
	G0 X{x_center_max} Y{y_center_min} F{speed*60}
	G0 X{x_center_min} Y{y_center_max} F{speed*60}
	G0 X{x_center_max} Y{y_center_min} F{speed*60}
	
	
	G0 X{x_center_min} Y{y_center_min} F{speed*60}
	G0 X{x_center_min} Y{y_center_max} F{speed*60}
	G0 X{x_center_max} Y{y_center_max} F{speed*60}
	G0 X{x_center_max} Y{y_center_min} F{speed*60}
	{% endfor %}
	
	
	SET_VELOCITY_LIMIT VELOCITY={printer.configfile.settings.printer.max_velocity} ACCEL={printer.configfile.settings.printer.max_accel} ACCEL_TO_DECEL={printer.configfile.settings.printer.max_accel_to_decel}
	
	
	M400
	G28
	
	G90
	G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
	G4 P1000
	GET_POSITION
	
	
	RESTORE_GCODE_STATE NAME=TEST_SPEED

[gcode_macro BED_MESH_CALIBRATE]
rename_existing = _BED_MESH_CALIBRATE
gcode = 
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}
	{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}
	{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}
	{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}
	{% set verbose_enable = kamp_settings.verbose_enable | abs %}
	{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}
	{% set attach_macro = kamp_settings.attach_macro | string %}
	{% set detach_macro = kamp_settings.detach_macro | string %}
	{% set mesh_margin = kamp_settings.mesh_margin | float %}
	{% set fuzz_amount = kamp_settings.fuzz_amount | float %}
	{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}
	{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}
	{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}
	{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}
	{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}
	{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}
	{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}
	
	{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}
	{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}
	{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}
	{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}
	{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}
	
	{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}
	{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}
	{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}
	{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}
	
	{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method='ceil') | int) + 1 %}
	{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method='ceil') | int) + 1 %}
	
	{% if (([points_x, points_y]|max) > 6) %}
	{% set algorithm = "bicubic" %}
	{% set min_points = 4 %}
	{% else %}
	{% set algorithm = "lagrange" %}
	{% set min_points = 3 %}
	{% endif %}
	
	{% set points_x = [points_x , min_points]|max %}
	{% set points_y = [points_y , min_points]|max %}
	{% set points_x = [points_x , probe_count[0]]|min %}
	{% set points_y = [points_y , probe_count[1]]|min %}
	
	{% if verbose_enable == True %}
	{% if printer.exclude_object.objects != [] %}
	
	{ action_respond_info( "Algorithm: {}.".format(
	(algorithm),
	)) }
	
	{ action_respond_info("Default probe count: {},{}.".format(
	(probe_count[0]),
	(probe_count[1]),
	)) }
	
	{ action_respond_info("Adapted probe count: {},{}.".format(
	(points_x),
	(points_y),
	)) }
	
	{action_respond_info("Default mesh bounds: {}, {}.".format(
	(bed_mesh_min[0],bed_mesh_min[1]),
	(bed_mesh_max[0],bed_mesh_max[1]),
	)) }
	
	{% if mesh_margin > 0 %}
	{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(
	(mesh_margin),
	(mesh_margin),
	)) }
	{% else %}
	{action_respond_info("Mesh margin is 0, margin not increased.")}
	{% endif %}
	
	{% if fuzz_amount > 0 %}
	{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(
	(fuzz_amount),
	)) }
	{% else %}
	{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}
	{% endif %}
	
	{ action_respond_info("Adapted mesh bounds: {}, {}.".format(
	(adapted_x_min, adapted_y_min),
	(adapted_x_max, adapted_y_max),
	)) }
	
	{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}
	
	{% else %}
	
	{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}
	G4 P5000
	{% endif %}
	
	{% endif %}
	
	{% if probe_dock_enable == True %}
	{attach_macro}
	{% endif %}
	
	_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}
	
	{% if probe_dock_enable == True %}
	{detach_macro}
	{% endif %}

[gcode_macro LINE_PURGE]
description = A purge macro that adapts to be near your actual printed objects
gcode = 
	
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}
	
	
	{% if printer.firmware_retraction is defined %}
	{% set RETRACT = G10 | string %}
	{% set UNRETRACT = G11 | string %}
	{% else %}
	{% set RETRACT = 'G1 E-.5 F2100' | string %}
	{% set UNRETRACT = 'G1 E.5 F2100' | string %}
	{% endif %}
	
	
	{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}
	{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}
	{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}
	{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}
	{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}
	{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}
	
	
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}
	{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}
	{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}
	{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}
	
	{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}
	{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}
	
	{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}
	{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}
	
	
	{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}
	
	{% if cross_section < 5 %}
	
	{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}
	
	{% else %}
	
	{% if verbose_enable == True %}
	
	{action_respond_info("Moving filament tip {}mms".format(
	(tip_distance),
	)) }
	{% endif %}
	
	{% if printer.firmware_retraction is defined %}
	{action_respond_info("KAMP purge is using firmware retraction.")}
	{% else %}
	{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}
	{% endif %}
	
	{% if purge_y_origin > 0 %}
	
	{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm3/s.".format(
	(purge_x_center),
	(purge_y_origin),
	(purge_amount),
	(flow_rate),
	)) }
	
	{% else %}
	
	{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm3/s.".format(
	(purge_x_origin),
	(purge_y_center),
	(purge_amount),
	(flow_rate),
	)) }
	
	{% endif %}
	
	SAVE_GCODE_STATE NAME=Prepurge_State
	
	{% if purge_y_origin > 0 %}
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_center} Y{purge_y_origin}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}
	{RETRACT}
	G0 X{purge_x_center + purge_amount + 10} F{travel_speed}
	G92 E0
	M82
	G0 Z{purge_height * 2} F{travel_speed}
	
	{% else %}
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_origin} Y{purge_y_center}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}
	{RETRACT}
	G0 Y{purge_y_center + purge_amount + 10} F{travel_speed}
	G92 E0
	M82
	G0 Z{purge_height * 2} F{travel_speed}
	
	{% endif %}
	
	RESTORE_GCODE_STATE NAME=Prepurge_State
	
	{% endif %}

[gcode_macro SMART_PARK]
description = Parks your printhead near the print area for pre-print hotend heating.
gcode = 
	
	{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}
	{% set z_height = kamp_settings.smart_park_height | float %}
	{% set purge_margin = kamp_settings.purge_margin | float %}
	{% set verbose_enable = kamp_settings.verbose_enable | abs %}
	{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}
	{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}
	{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}
	{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}
	{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	
	{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}
	{% set x_min = [ x_min - purge_margin , x_min ] | min %}
	{% set y_min = [ y_min - purge_margin , y_min ] | min %}
	{% set x_min = [ x_min , axis_minimum_x ] | max %}
	{% set y_min = [ y_min , axis_minimum_y ] | max %}
	{% endif %}
	
	
	{% if verbose_enable == True %}
	
	{ action_respond_info("Smart Park location: {},{}.".format(
	(x_min),
	(y_min),
	)) }
	
	{% endif %}
	
	SAVE_GCODE_STATE NAME=Presmartpark_State
	
	G90
	{% if printer.toolhead.position.z < z_height %}
	G0 Z{z_height}
	{% endif %}
	G0 X{x_min} Y{y_min} F{travel_speed}
	G0 Z{z_height}
	
	RESTORE_GCODE_STATE NAME=Presmartpark_State

[gcode_macro _KAMP_Settings]
description = This macro contains all adjustable settings for KAMP
variable_verbose_enable = True
variable_mesh_margin = 0
variable_fuzz_amount = 0
variable_probe_dock_enable = True
variable_attach_macro = 'PROBE_OUT'
variable_detach_macro = 'PROBE_IN'
variable_purge_height = 0.8
variable_tip_distance = 3
variable_purge_margin = 10
variable_purge_amount = 30
variable_flow_rate = 10
variable_smart_park_height = 10
gcode = 
	
	{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}

[fcm]
topic = Alertas_M01

[mcu]
serial = /dev/ttyAMA0

[mcu rpi]
serial = /tmp/klipper_host_mcu

[printer]
kinematics = cartesian
max_velocity = 450
max_accel = 3500
max_z_velocity = 50
max_z_accel = 150

[adxl345]
cs_pin = rpi:None
spi_bus = spidev0.0

[resonance_tester]
accel_chip = adxl345
probe_points = 
	115, 115, 40

[input_shaper]
shaper_freq_x = 69
shaper_type_x = 2hump_ei
shaper_freq_y = 34.6
shaper_type_y = mzv

[skew_correction]

[exclude_object]

[gcode_arcs]
resolution = 0.1

[display]
lcd_type = ssd1306
i2c_mcu = rpi
i2c_bus = i2c.1
i2c_address = 60

[gcode_button button_pause]
pin = ^rpi:gpio27
press_gcode = PAUSE

[gcode_button button_play]
pin = ^rpi:gpio17
press_gcode = RESUME

[gcode_button button_cancel]
pin = ^rpi:gpio22
press_gcode = CANCEL_PRINT

[temperature_sensor raspberry_pi]
sensor_type = temperature_host
min_temp = 10
max_temp = 100

[filament_switch_sensor extruder_filament_sensor]
pause_on_runout = True
event_delay = 2.0
switch_pin = P1.24

[heater_bed]
heater_pin = P2.5
sensor_type = EPCOS 100K B57560G104F
sensor_pin = P0.23
min_temp = 10
max_temp = 130
control = pid
pid_kp = 66.889
pid_ki = 1.512
pid_kd = 739.954

[probe]
pin = ^P1.25
x_offset = 4
y_offset = 21
speed = 5.0
lift_speed = 15.0
sample_retract_dist = 1
samples = 4
samples_tolerance = 0.01
samples_result = median
samples_tolerance_retries = 3
z_offset = 5.549

[homing_override]
set_position_z = 0
gcode = 
	G90
	G1 Z10 F3000
	G28 X
	G28 Y
	PROBE_OUT
	G1 X117 Y117 F6000
	G28 Z
	_Z_TILT_ADJUST
	PROBE_IN

[bed_mesh]
speed = 120
horizontal_move_z = 10
mesh_min = 20, 20
mesh_max = 184, 200
probe_count = 4, 4
algorithm = bicubic
fade_start = 1
fade_end = 10
fade_target = 0

[screws_tilt_adjust]
screw1 = 24, 2
screw1_name = front left screw
screw2 = 24, 170
screw2_name = front right screw
screw3 = 198, 170
screw3_name = rear right screw
screw4 = 198, 37
screw4_name = rear left screw
horizontal_move_z = 10.
speed = 50.
screw_thread = CW-M4

[tmc2130 stepper_x]
cs_pin = P1.17
spi_software_sclk_pin = P0.4
spi_software_mosi_pin = P4.28
spi_software_miso_pin = P0.5
run_current = 0.8
stealthchop_threshold = 9999999

[stepper_x]
step_pin = P2.2
dir_pin = !P2.6
enable_pin = !P2.1
endstop_pin = P1.29
position_endstop = 0
position_min = 0
position_max = 245
homing_speed = 70
microsteps = 16
rotation_distance = 40

[tmc2130 stepper_y]
cs_pin = P1.15
spi_software_sclk_pin = P0.4
spi_software_mosi_pin = P4.28
spi_software_miso_pin = P0.5
run_current = 0.8
stealthchop_threshold = 999999

[stepper_y]
step_pin = P0.19
dir_pin = !P0.20
enable_pin = !P2.8
endstop_pin = P1.27
position_endstop = -18
position_min = -18
position_max = 219
homing_speed = 70
microsteps = 16
rotation_distance = 40

[tmc2130 stepper_z]
cs_pin = P1.10
spi_software_sclk_pin = P0.4
spi_software_mosi_pin = P4.28
spi_software_miso_pin = P0.5
run_current = 0.75
stealthchop_threshold = 999999

[stepper_z]
step_pin = P0.22
dir_pin = P2.11
enable_pin = !P0.21
endstop_pin = probe:z_virtual_endstop
position_min = -8
position_max = 250
microsteps = 16
rotation_distance = 8

[z_tilt]
z_positions = 
	
	
	-30, 117
	265, 117
points = 
	4, 96.5
	210, 96.5
speed = 100
horizontal_move_z = 15
retries = 10
retry_tolerance = 0.005

[tmc2130 stepper_z1]
cs_pin = P1.8
spi_software_sclk_pin = P0.4
spi_software_mosi_pin = P4.28
spi_software_miso_pin = P0.5
run_current = 0.75
stealthchop_threshold = 999999

[stepper_z1]
step_pin = P2.13
dir_pin = !P0.11
enable_pin = !P2.12
endstop_pin = probe:z_virtual_endstop
microsteps = 16
rotation_distance = 8

[extruder]
step_pin = P0.1
dir_pin = !P0.0
enable_pin = !P0.10
microsteps = 64
rotation_distance = 7.655
nozzle_diameter = 0.400
filament_diameter = 1.750
heater_pin = P2.7
sensor_type = EPCOS 100K B57560G104F
sensor_pin = P0.24
min_temp = 10
max_temp = 290
pressure_advance = 0
max_extrude_only_distance = 105
max_extrude_cross_section = 5
control = pid
pid_kp = 25.511
pid_ki = 1.260
pid_kd = 129.148

[fan]
pin = P2.3
off_below = 0.15
hardware_pwm = False
cycle_time = 0.0050
kick_start_time = 0.150

[heater_fan noozle_fan]
heater = extruder
heater_temp = 50
fan_speed = 1.0
pin = P2.4

[bed_mesh default-old]
version = 1
points = 
	-0.022079, 0.022088, 0.011254, 0.027088
	0.012921, 0.040421, -0.008746, -0.018746
	0.093754, 0.110421, 0.029588, 0.001254
	0.163754, 0.164588, 0.063754, 0.016254
min_x = 20.0
max_x = 183.97
min_y = 20.0
max_y = 200.0
x_count = 4
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = bicubic
tension = 0.2

[bed_mesh default-glass]
version = 1
points = 
	0.000833, 0.016667, 0.023333, 0.006667
	-0.005833, 0.020833, -0.001667, -0.035000
	0.048333, 0.052500, 0.000833, -0.075000
	0.061667, 0.064167, 0.026667, -0.053333
min_x = 20.0
max_x = 183.97
min_y = 20.0
max_y = 200.0
x_count = 4
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = bicubic
tension = 0.2

[bed_mesh default - NonGlass]
version = 1
points = 
	-0.036760, -0.065927, -0.185094, -0.310094
	0.074073, 0.348240, 0.306573, -0.021760
	0.164906, 0.391573, 0.324073, -0.094260
	0.124073, 0.049906, -0.080094, -0.450094
min_x = 20.0
max_x = 183.97
min_y = 20.0
max_y = 200.0
x_count = 4
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = bicubic
tension = 0.2

[bed_mesh default]
version = 1
points = 
	0.115316, 0.126566, 0.134066
	0.069066, 0.076566, 0.074066
	-0.025934, -0.009684, -0.008434
	-0.078434, -0.095934, -0.103434
x_count = 3
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = lagrange
tension = 0.2
min_x = 23.19
max_x = 65.19
min_y = 38.35
max_y = 169.34
=======================
Extruder max_extrude_ratio=2.078758
mcu 'mcu': Starting serial connect
webhooks client 1962735048: New connection
webhooks client 1962735048: Client info {'program': 'Moonraker', 'version': 'v0.8.0-343-g0f2e3d7'}
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
MCU error during connect
Traceback (most recent call last):
  File "/home/m/klipper/klippy/mcu.py", line 791, in _mcu_identify
    self._serial.connect_uart(self._serialport, self._baud, rts)
  File "/home/m/klipper/klippy/serialhdl.py", line 183, in connect_uart
    self._error("Unable to connect")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Unable to connect

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/m/klipper/klippy/klippy.py", line 176, in _connect
    self.send_event("klippy:mcu_identify")
  File "/home/m/klipper/klippy/klippy.py", line 263, in send_event
    return [cb(*params) for cb in self.event_handlers.get(event, [])]
  File "/home/m/klipper/klippy/klippy.py", line 263, in <listcomp>
    return [cb(*params) for cb in self.event_handlers.get(event, [])]
  File "/home/m/klipper/klippy/mcu.py", line 796, in _mcu_identify
    raise error(str(e))
mcu.error: mcu 'mcu': Unable to connect
Build file /home/m/klipper/klippy/../.config(1427): Sat Apr  6 11:05:37 2024
========= Last MCU build config =========
# CONFIG_LOW_LEVEL_OPTIONS is not set
# CONFIG_MACH_AVR is not set
# CONFIG_MACH_ATSAM is not set
# CONFIG_MACH_ATSAMD is not set
CONFIG_MACH_LPC176X=y
# CONFIG_MACH_STM32 is not set
# CONFIG_MACH_HC32F460 is not set
# CONFIG_MACH_RP2040 is not set
# CONFIG_MACH_PRU is not set
# CONFIG_MACH_AR100 is not set
# CONFIG_MACH_LINUX is not set
# CONFIG_MACH_SIMU is not set
CONFIG_BOARD_DIRECTORY="lpc176x"
CONFIG_MCU="lpc1768"
CONFIG_CLOCK_FREQ=100000000
CONFIG_SERIAL=y
CONFIG_FLASH_SIZE=0x80000
CONFIG_FLASH_BOOT_ADDRESS=0x0
CONFIG_RAM_START=0x10000000
CONFIG_RAM_SIZE=0x7fe0
CONFIG_STACK_SIZE=512
CONFIG_FLASH_APPLICATION_ADDRESS=0x4000
CONFIG_LPC_SELECT=y
CONFIG_MACH_LPC1768=y
# CONFIG_MACH_LPC1769 is not set
CONFIG_LPC_FLASH_START_4000=y
# CONFIG_LPC_FLASH_START_0000 is not set
# CONFIG_LPC_USB is not set
CONFIG_LPC_SERIAL_UART0_P03_P02=y
CONFIG_SERIAL_BAUD=250000
CONFIG_USB_VENDOR_ID=0x1d50
CONFIG_USB_DEVICE_ID=0x614e
CONFIG_USB_SERIAL_NUMBER="12345"
CONFIG_WANT_GPIO_BITBANGING=y
CONFIG_WANT_DISPLAYS=y
CONFIG_WANT_SENSORS=y
CONFIG_WANT_LIS2DW=y
CONFIG_WANT_SOFTWARE_I2C=y
CONFIG_WANT_SOFTWARE_SPI=y
CONFIG_NEED_SENSOR_BULK=y
CONFIG_CANBUS_FREQUENCY=1000000
CONFIG_HAVE_GPIO=y
CONFIG_HAVE_GPIO_ADC=y
CONFIG_HAVE_GPIO_SPI=y
CONFIG_HAVE_GPIO_I2C=y
CONFIG_HAVE_GPIO_HARD_PWM=y
CONFIG_HAVE_STRICT_TIMING=y
CONFIG_HAVE_CHIPID=y
CONFIG_HAVE_STEPPER_BOTH_EDGE=y
CONFIG_HAVE_BOOTLOADER_REQUEST=y
CONFIG_INLINE_STEPPER_HACK=y
=======================
Build file /home/m/klipper/klippy/../out/klipper.dict(7495): Sat Apr  6 11:06:00 2024
Last MCU build version: v0.12.0-143-g01c7befa
Last MCU build tools: gcc: (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revision 273027] binutils: (2.34-4+rpi1+14) 2.34
Last MCU build config: ADC_MAX=4095 BUS_PINS_i2c0=P0.28,P0.27 BUS_PINS_i2c1=P0.1,P0.0 BUS_PINS_i2c1a=P0.20,P0.19 BUS_PINS_i2c2=P0.11,P0.10 BUS_PINS_ssp0=P0.17,P0.18,P0.15 BUS_PINS_ssp1=P0.8,P0.9,P0.7 CLOCK_FREQ=100000000 MCU=lpc1768 PWM_MAX=255 RECEIVE_WINDOW=192 RESERVE_PINS_serial=P0.3,P0.2 SERIAL_BAUD=250000 STATS_SUMSQ_BASE=256 STEPPER_BOTH_EDGE=1
Build file /home/m/klipper/klippy/../out/klipper.elf(595688): Sat Apr  6 11:06:10 2024
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
Starting Klippy...
Args: ['/home/m/klipper/klippy/klippy.py', '/home/m/printer_data/config/printer.cfg', '-l', '/home/m/printer_data/logs/klippy.log', '-I', '/home/m/printer_data/comms/klippy.serial', '-a', '/home/m/printer_data/comms/klippy.sock']
Git version: 'v0.12.0-178-g7e8c7f46-dirty'
Untracked files: klippy/extras/fcm.py
Branch: master
Remote: origin
Tracked URL: https://github.com/Klipper3d/klipper.git
CPU: 4 core ARMv7 Processor rev 4 (v7l)
Python: '3.9.2 (default, Mar 12 2021, 04:06:34) \n[GCC 10.2.1 20210110]'
Start printer at Sun Jun  9 16:34:56 2024 (1717965297.0 46.6)
===== Config file =====
[virtual_sdcard]
path = /home/m/printer_data/gcodes
on_error_gcode = CANCEL_PRINT

[pause_resume]

[display_status]

[respond]

[gcode_macro CANCEL_PRINT]
description = Cancel the actual running print
rename_existing = CANCEL_PRINT_BASE
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set allow_park = client.park_at_cancel|default(false)|lower == 'true' %}
	{% set retract = client.cancel_retract|default(5.0)|abs %}
	
	{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)
	else "X=" ~ client.park_at_cancel_x %}
	{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)
	else "Y=" ~ client.park_at_cancel_y %}
	{% set custom_park = park_x|length > 0 or park_y|length > 0 %}
	
	
	{% if printer['gcode_macro RESUME'].restore_idle_timeout > 0 %}
	SET_IDLE_TIMEOUT TIMEOUT={printer['gcode_macro RESUME'].restore_idle_timeout}
	{% endif %}
	{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}
	_CLIENT_RETRACT LENGTH={retract}
	TURN_OFF_HEATERS
	M106 S0
	{client.user_cancel_macro|default("")}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False
	
	SET_PAUSE_NEXT_LAYER ENABLE=0
	SET_PAUSE_AT_LAYER ENABLE=0 LAYER=0
	CANCEL_PRINT_BASE

[gcode_macro PAUSE]
description = Pause the actual running print
rename_existing = PAUSE_BASE
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set idle_timeout = client.idle_timeout|default(0) %}
	{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != '' else 0 %}
	{% set restore = False if printer.toolhead.extruder == ''
	else True  if params.RESTORE|default(1)|int == 1 else False %}
	
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{'restore': restore, 'temp': temp}}"
	
	{% if idle_timeout > 0 %}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}
	SET_IDLE_TIMEOUT TIMEOUT={idle_timeout}
	{% endif %}
	PAUSE_BASE
	{client.user_pause_macro|default("")}
	_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}

[gcode_macro RESUME]
description = Resume the actual running print
rename_existing = RESUME_BASE
variable_last_extruder_temp = {'restore': False, 'temp': 0}
variable_restore_idle_timeout = 0
variable_idle_state = False
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set sp_move = client.speed_move|default(velocity) %}
	{% set runout_resume = True if client.runout_sensor|default("") == ""
	else True if not printer[client.runout_sensor].enabled
	else printer[client.runout_sensor].filament_detected %}
	{% set can_extrude = True if printer.toolhead.extruder == ''
	else printer[printer.toolhead.extruder].can_extrude %}
	{% set do_resume = False %}
	{% set prompt_txt = [] %}
	
	
	{% if printer.idle_timeout.state|upper == "IDLE" or idle_state %}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=idle_state VALUE=False
	{% if last_extruder_temp.restore %}
	
	RESPOND TYPE=echo MSG='{"Restoring \"%s\" temperature to %3.1f\u00B0C, this may take some time" % (printer.toolhead.extruder, last_extruder_temp.temp) }'
	M109 S{last_extruder_temp.temp}
	{% set do_resume = True %}
	{% elif can_extrude %}
	{% set do_resume = True %}
	{% else %}
	RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}'
	{% set _d = prompt_txt.append("\"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder) %}
	{% endif %}
	
	{% elif can_extrude %}
	{% set do_resume = True %}
	{% else %}
	RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder}'
	{% set _d = prompt_txt.append("\"%s\" not hot enough, please heat up again and press RESUME" % printer.toolhead.extruder) %}
	{% endif %}
	{% if runout_resume %}
	{% if do_resume %}
	{% if restore_idle_timeout > 0 %} SET_IDLE_TIMEOUT TIMEOUT={restore_idle_timeout} {% endif %}
	{client.user_resume_macro|default("")}
	_CLIENT_EXTRUDE
	RESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}
	{% endif %}
	{% else %}
	RESPOND TYPE=error MSG='{"Resume aborted !!! \"%s\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]}'
	{% set _d = prompt_txt.append("\"%s\" detects no filament, please load filament and press RESUME" % (client.runout_sensor.split(" "))[1]) %}
	{% endif %}
	
	{% if not (runout_resume and do_resume) %}
	RESPOND TYPE=command MSG="action:prompt_begin RESUME aborted !!!"
	{% for element in prompt_txt %}
	RESPOND TYPE=command MSG='{"action:prompt_text %s" % element}'
	{% endfor %}
	RESPOND TYPE=command MSG="action:prompt_footer_button Ok|RESPOND TYPE=command MSG=action:prompt_end|info"
	RESPOND TYPE=command MSG="action:prompt_show"
	{% endif %}

[gcode_macro SET_PAUSE_NEXT_LAYER]
description = Enable a pause if the next layer is reached
gcode = 
	{% set pause_next_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer %}
	{% set ENABLE = params.ENABLE|default(1)|int != 0 %}
	{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ 'enable': ENABLE, 'call': MACRO }}"

[gcode_macro SET_PAUSE_AT_LAYER]
description = Enable/disable a pause if a given layer number is reached
gcode = 
	{% set pause_at_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer %}
	{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined
	else params.LAYER is defined %}
	{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}
	{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ 'enable': ENABLE, 'layer': LAYER, 'call': MACRO }}"

[gcode_macro SET_PRINT_STATS_INFO]
rename_existing = SET_PRINT_STATS_INFO_BASE
description = Overwrite, to get pause_next_layer and pause_at_layer feature
variable_pause_next_layer = { 'enable': False, 'call': "PAUSE" }
variable_pause_at_layer = { 'enable': False, 'layer': 0, 'call': "PAUSE" }
gcode = 
	{% if pause_next_layer.enable %}
	RESPOND TYPE=echo MSG='{"%s, forced by pause_next_layer" % pause_next_layer.call}'
	{pause_next_layer.call}
	SET_PAUSE_NEXT_LAYER ENABLE=0
	{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}
	RESPOND TYPE=echo MSG='{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}'
	{pause_at_layer.call}
	SET_PAUSE_AT_LAYER ENABLE=0
	{% endif %}
	SET_PRINT_STATS_INFO_BASE {rawparams}

[gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL]
description = Helper: park toolhead used in PAUSE and CANCEL_PRINT
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set use_custom     = client.use_custom_pos|default(false)|lower == 'true' %}
	{% set custom_park_x  = client.custom_park_x|default(0.0) %}
	{% set custom_park_y  = client.custom_park_y|default(0.0) %}
	{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}
	{% set sp_hop         = client.speed_hop|default(15) * 60 %}
	{% set sp_move        = client.speed_move|default(velocity) * 60 %}
	
	{% set origin    = printer.gcode_move.homing_origin %}
	{% set act       = printer.gcode_move.gcode_position %}
	{% set max       = printer.toolhead.axis_maximum %}
	{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}
	{% set round_bed = True if printer.configfile.settings.printer.kinematics is in ['delta','polar','rotary_delta','winch']
	else False %}
	
	{% set z_min = params.Z_MIN|default(0)|float %}
	{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}
	{% set x_park = params.X       if params.X is defined
	else custom_park_x  if use_custom
	else 0.0            if round_bed
	else (max.x - 5.0) %}
	{% set y_park = params.Y       if params.Y is defined
	else custom_park_y  if use_custom
	else (max.y - 5.0)  if round_bed and z_park < cone
	else 0.0            if round_bed
	else (max.y - 5.0) %}
	
	_CLIENT_RETRACT
	{% if "xyz" in printer.toolhead.homed_axes %}
	G90
	G1 Z{z_park} F{sp_hop}
	G1 X{x_park} Y{y_park} F{sp_move}
	{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}
	{% else %}
	RESPOND TYPE=echo MSG='Printer not homed'
	{% endif %}

[gcode_macro _CLIENT_EXTRUDE]
description = Extrudes, if the extruder is hot enough
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}
	{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}
	{% set absolute_extrude = printer.gcode_move.absolute_extrude %}
	
	{% if printer.toolhead.extruder != '' %}
	{% if printer[printer.toolhead.extruder].can_extrude %}
	{% if use_fw_retract %}
	{% if length < 0 %}
	G10
	{% else %}
	G11
	{% endif %}
	{% else %}
	M83
	G1 E{length} F{(speed|float|abs) * 60}
	{% if absolute_extrude %}
	M82
	{% endif %}
	{% endif %}
	{% else %}
	RESPOND TYPE=echo MSG='{"\"%s\" not hot enough" % printer.toolhead.extruder}'
	{% endif %}
	{% endif %}

[gcode_macro _CLIENT_RETRACT]
description = Retracts, if the extruder is hot enough
gcode = 
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}
	
	_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}

[gcode_macro _CLIENT_VARIABLE]
gcode = 

[gcode_macro PROBE_OUT]
gcode = 
	G90
	G1 X245 F4000
	G4 P300
	G1 Z15
	G1 X0

[gcode_macro PROBE_IN]
gcode = 
	G90
	G1 Z20
	G1 X245 F20000
	G1 Y-8
	G1 Z0
	G4 P300
	G1 X220 F6000
	G1 Z10
	G1 X0

[gcode_macro Accuracy_Test]
gcode = 
	PROBE_OUT
	G90
	G1 Y120 X120 F20000
	PROBE_ACCURACY
	PROBE_IN

[gcode_macro SCREWS_TILT_CALCULATE]
rename_existing = _SCREWS_TILT_CALCULATE
gcode = 
	PROBE_OUT
	_SCREWS_TILT_CALCULATE
	PROBE_IN

[gcode_macro Z_TILT_ADJUST]
rename_existing = _Z_TILT_ADJUST
gcode = 
	PROBE_OUT
	_Z_TILT_ADJUST
	PROBE_IN

[gcode_macro CLEAN_NOZZLE]
variable_start_x = 185
variable_start_y = -15
variable_fuzz_amount = 2
variable_start_z = 3
variable_wipe_dist = 45
variable_wipe_qty = 6
variable_wipe_spd = 400
variable_raise_distance = 10
variable_clear_distance = 10
gcode = 
	{% if "xyz" in printer.toolhead.homed_axes %}
	{% set fuzz_range = range ( ( ( (fuzz_amount * 100) | int + 1 ) * -1 ), (fuzz_amount * 100) | int + 1) %}
	{% set adapted_y = start_y + (fuzz_range | random / 100.0) %}
	
	SAVE_GCODE_STATE NAME=clean_nozzle
	G90
	
	G1 X{start_x} Y{adapted_y} F6000
	G1 Z{start_z} F1500
	
	G1 E-2 F3000
	
	
	{% for wipes in range(1, (wipe_qty + 1)) %}
	G1 X{start_x + wipe_dist} F{wipe_spd * 60}
	G1 X{start_x} F{wipe_spd * 60}
	{% endfor %}
	
	G1 Z{raise_distance} F3000
	G1 Y{clear_distance} F6000
	SET_DISPLAY_TEXT MSG="Cleaned!"
	
	RESTORE_GCODE_STATE NAME=clean_nozzle
	{% else %}
	
	
	{ action_raise_error("Please home your axes!") }
	SET_DISPLAY_TEXT MSG="Please home first!"
	{% endif %}

[gcode_macro PRINT_START]
gcode = 
	
	{% set target_bed = params.BED|int %}
	{% set target_extruder = params.EXTRUDER|int %}
	{% set target_chamber = params.CHAMBER|default("40")|int %}
	{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}
	{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}
	M140 S{target_bed}
	M104 S150
	SET_SKEW XY=141.2,141.2,99.8
	
	
	BED_MESH_CLEAR
	
	SET_DISPLAY_TEXT MSG="Hotend: 150c"
	
	M190 S{target_bed}
	G28
	
	
	
	G90
	M82
	G1 X{x_wait} Y{y_wait} Z15 F9000
	M109 S150
	
	SET_DISPLAY_TEXT MSG="Bed mesh"
	bed_mesh_calibrate
	
	
	SET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"
	
	SMART_PARK
	M107
	M109 S{target_extruder}
	
	
	CLEAN_NOZZLE
	SET_DISPLAY_TEXT MSG="Printer goes brr"
	
	
	
	
	
	
	
	
	
	LINE_PURGE

[gcode_macro PRINT_END]
gcode = 
	SET_DISPLAY_TEXT MSG="Print Finished"
	
	M140 S0
	M104 S0
	M106 S0
	
	G91
	G1 X-2 Y-2 E-3 F300
	
	G1 Z10 F3000
	G90
	G0 Y170 X10
	
	M84
	FCM_NOTIFY MSG="Printing Done" TITLE="Ender3"
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=30

[gcode_macro _POWER_OFF_PRINTER]
gcode = 
	{action_call_remote_method("set_device_power",
	device="printer",
	state="off")}

[delayed_gcode POWER_OFF_PRINTER_CHECK]
gcode = 
	{% if printer.idle_timeout.state == "Idle" or printer.idle_timeout.state == "Ready" %}
	{% if printer.extruder.temperature < 50.0 and printer.heater_bed.temperature < 50.0 %}
	{% if printer.extruder.target == 0.0 and printer.heater_bed.target == 0.0 %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=0
	SET_DISPLAY_TEXT MSG="PowerOff Printer"
	_POWER_OFF_PRINTER
	{% else %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=2
	{% endif %}
	{% else %}
	{% if printer.idle_timeout.state == "Printing" %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=0
	{% else %}
	{% if printer.extruder.target == 0.0 and printer.heater_bed.target == 0.0 %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=2
	{% else %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=0
	{% endif %}
	{% endif %}
	{% endif %}
	{% endif %}

[gcode_macro ACTIVATE_POWER_OFF]
gcode = 
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK_ACT DURATION=60

[gcode_macro DEACTIVATE_POWER_OFF]
gcode = 
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK_ACT DURATION=0

[delayed_gcode POWER_OFF_PRINTER_CHECK_ACT]
gcode = 
	{% if printer.idle_timeout.state == "Idle" or printer.idle_timeout.state == "Ready" %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK DURATION=30
	{% else %}
	UPDATE_DELAYED_GCODE ID=POWER_OFF_PRINTER_CHECK_ACT DURATION=60
	{% endif %}

[gcode_macro M600]
gcode = 
	
	PAUSE

[gcode_macro _bot_data]
variable_lapse_video_size = 0
variable_lapse_filename = 'None'
variable_lapse_path = 'None'
gcode = 
	M118 Setting bot lapse variables

[gcode_macro TEST_SPEED]
gcode = 
	
	{% set speed  = params.SPEED|default(printer.configfile.settings.printer.max_velocity)|int %}
	
	{% set iterations = params.ITERATIONS|default(5)|int %}
	
	{% set accel  = params.ACCEL|default(printer.configfile.settings.printer.max_accel)|int %}
	
	{% set bound = params.BOUND|default(20)|int %}
	
	{% set smallpatternsize = SMALLPATTERNSIZE|default(20)|int %}
	
	
	
	{% set x_min = printer.toolhead.axis_minimum.x + bound %}
	{% set x_max = printer.toolhead.axis_maximum.x - bound %}
	{% set y_min = printer.toolhead.axis_minimum.y + bound %}
	{% set y_max = printer.toolhead.axis_maximum.y - bound %}
	
	
	
	{% set x_center = (printer.toolhead.axis_minimum.x|float + printer.toolhead.axis_maximum.x|float ) / 2 %}
	{% set y_center = (printer.toolhead.axis_minimum.y|float + printer.toolhead.axis_maximum.y|float ) / 2 %}
	
	
	{% set x_center_min = x_center - (smallpatternsize/2) %}
	{% set x_center_max = x_center + (smallpatternsize/2) %}
	{% set y_center_min = y_center - (smallpatternsize/2) %}
	{% set y_center_max = y_center + (smallpatternsize/2) %}
	
	
	SAVE_GCODE_STATE NAME=TEST_SPEED
	
	
	{ action_respond_info("TEST_SPEED: starting %d iterations at speed %d, accel %d" % (iterations, speed, accel)) }
	
	
	M400
	G28
	
	{% if printer.configfile.settings.quad_gantry_level %}
	{% if printer.quad_gantry_level.applied == False %}
	QUAD_GANTRY_LEVEL
	G28 Z
	{% endif %}
	{% endif %}
	
	G90
	G1 X{printer.toolhead.axis_maximum.x-50} Y{printer.toolhead.axis_maximum.y-50} F{30*60}
	M400
	G28 X Y
	G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
	G4 P1000
	GET_POSITION
	
	
	G0 X{x_min} Y{y_min} Z{bound + 10} F{speed*60}
	
	
	SET_VELOCITY_LIMIT VELOCITY={speed} ACCEL={accel} ACCEL_TO_DECEL={accel / 2}
	
	{% for i in range(iterations) %}
	
	G0 X{x_min} Y{y_min} F{speed*60}
	G0 X{x_max} Y{y_max} F{speed*60}
	G0 X{x_min} Y{y_min} F{speed*60}
	G0 X{x_max} Y{y_min} F{speed*60}
	G0 X{x_min} Y{y_max} F{speed*60}
	G0 X{x_max} Y{y_min} F{speed*60}
	
	
	G0 X{x_min} Y{y_min} F{speed*60}
	G0 X{x_min} Y{y_max} F{speed*60}
	G0 X{x_max} Y{y_max} F{speed*60}
	G0 X{x_max} Y{y_min} F{speed*60}
	
	
	G0 X{x_center_min} Y{y_center_min} F{speed*60}
	G0 X{x_center_max} Y{y_center_max} F{speed*60}
	G0 X{x_center_min} Y{y_center_min} F{speed*60}
	G0 X{x_center_max} Y{y_center_min} F{speed*60}
	G0 X{x_center_min} Y{y_center_max} F{speed*60}
	G0 X{x_center_max} Y{y_center_min} F{speed*60}
	
	
	G0 X{x_center_min} Y{y_center_min} F{speed*60}
	G0 X{x_center_min} Y{y_center_max} F{speed*60}
	G0 X{x_center_max} Y{y_center_max} F{speed*60}
	G0 X{x_center_max} Y{y_center_min} F{speed*60}
	{% endfor %}
	
	
	SET_VELOCITY_LIMIT VELOCITY={printer.configfile.settings.printer.max_velocity} ACCEL={printer.configfile.settings.printer.max_accel} ACCEL_TO_DECEL={printer.configfile.settings.printer.max_accel_to_decel}
	
	
	M400
	G28
	
	G90
	G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
	G4 P1000
	GET_POSITION
	
	
	RESTORE_GCODE_STATE NAME=TEST_SPEED

[gcode_macro BED_MESH_CALIBRATE]
rename_existing = _BED_MESH_CALIBRATE
gcode = 
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}
	{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}
	{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}
	{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}
	{% set verbose_enable = kamp_settings.verbose_enable | abs %}
	{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}
	{% set attach_macro = kamp_settings.attach_macro | string %}
	{% set detach_macro = kamp_settings.detach_macro | string %}
	{% set mesh_margin = kamp_settings.mesh_margin | float %}
	{% set fuzz_amount = kamp_settings.fuzz_amount | float %}
	{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}
	{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}
	{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}
	{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}
	{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}
	{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}
	{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}
	
	{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}
	{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}
	{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}
	{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}
	{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}
	
	{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}
	{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}
	{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}
	{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}
	
	{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method='ceil') | int) + 1 %}
	{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method='ceil') | int) + 1 %}
	
	{% if (([points_x, points_y]|max) > 6) %}
	{% set algorithm = "bicubic" %}
	{% set min_points = 4 %}
	{% else %}
	{% set algorithm = "lagrange" %}
	{% set min_points = 3 %}
	{% endif %}
	
	{% set points_x = [points_x , min_points]|max %}
	{% set points_y = [points_y , min_points]|max %}
	{% set points_x = [points_x , probe_count[0]]|min %}
	{% set points_y = [points_y , probe_count[1]]|min %}
	
	{% if verbose_enable == True %}
	{% if printer.exclude_object.objects != [] %}
	
	{ action_respond_info( "Algorithm: {}.".format(
	(algorithm),
	)) }
	
	{ action_respond_info("Default probe count: {},{}.".format(
	(probe_count[0]),
	(probe_count[1]),
	)) }
	
	{ action_respond_info("Adapted probe count: {},{}.".format(
	(points_x),
	(points_y),
	)) }
	
	{action_respond_info("Default mesh bounds: {}, {}.".format(
	(bed_mesh_min[0],bed_mesh_min[1]),
	(bed_mesh_max[0],bed_mesh_max[1]),
	)) }
	
	{% if mesh_margin > 0 %}
	{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(
	(mesh_margin),
	(mesh_margin),
	)) }
	{% else %}
	{action_respond_info("Mesh margin is 0, margin not increased.")}
	{% endif %}
	
	{% if fuzz_amount > 0 %}
	{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(
	(fuzz_amount),
	)) }
	{% else %}
	{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}
	{% endif %}
	
	{ action_respond_info("Adapted mesh bounds: {}, {}.".format(
	(adapted_x_min, adapted_y_min),
	(adapted_x_max, adapted_y_max),
	)) }
	
	{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}
	
	{% else %}
	
	{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}
	G4 P5000
	{% endif %}
	
	{% endif %}
	
	{% if probe_dock_enable == True %}
	{attach_macro}
	{% endif %}
	
	_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}
	
	{% if probe_dock_enable == True %}
	{detach_macro}
	{% endif %}

[gcode_macro LINE_PURGE]
description = A purge macro that adapts to be near your actual printed objects
gcode = 
	
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}
	
	
	{% if printer.firmware_retraction is defined %}
	{% set RETRACT = G10 | string %}
	{% set UNRETRACT = G11 | string %}
	{% else %}
	{% set RETRACT = 'G1 E-.5 F2100' | string %}
	{% set UNRETRACT = 'G1 E.5 F2100' | string %}
	{% endif %}
	
	
	{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}
	{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}
	{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}
	{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}
	{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}
	{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}
	
	
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}
	{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}
	{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}
	{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}
	
	{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}
	{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}
	
	{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}
	{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}
	
	
	{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}
	
	{% if cross_section < 5 %}
	
	{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}
	
	{% else %}
	
	{% if verbose_enable == True %}
	
	{action_respond_info("Moving filament tip {}mms".format(
	(tip_distance),
	)) }
	{% endif %}
	
	{% if printer.firmware_retraction is defined %}
	{action_respond_info("KAMP purge is using firmware retraction.")}
	{% else %}
	{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}
	{% endif %}
	
	{% if purge_y_origin > 0 %}
	
	{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm3/s.".format(
	(purge_x_center),
	(purge_y_origin),
	(purge_amount),
	(flow_rate),
	)) }
	
	{% else %}
	
	{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm3/s.".format(
	(purge_x_origin),
	(purge_y_center),
	(purge_amount),
	(flow_rate),
	)) }
	
	{% endif %}
	
	SAVE_GCODE_STATE NAME=Prepurge_State
	
	{% if purge_y_origin > 0 %}
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_center} Y{purge_y_origin}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}
	{RETRACT}
	G0 X{purge_x_center + purge_amount + 10} F{travel_speed}
	G92 E0
	M82
	G0 Z{purge_height * 2} F{travel_speed}
	
	{% else %}
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_origin} Y{purge_y_center}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}
	{RETRACT}
	G0 Y{purge_y_center + purge_amount + 10} F{travel_speed}
	G92 E0
	M82
	G0 Z{purge_height * 2} F{travel_speed}
	
	{% endif %}
	
	RESTORE_GCODE_STATE NAME=Prepurge_State
	
	{% endif %}

[gcode_macro SMART_PARK]
description = Parks your printhead near the print area for pre-print hotend heating.
gcode = 
	
	{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}
	{% set z_height = kamp_settings.smart_park_height | float %}
	{% set purge_margin = kamp_settings.purge_margin | float %}
	{% set verbose_enable = kamp_settings.verbose_enable | abs %}
	{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}
	{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}
	{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}
	{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}
	{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	
	{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}
	{% set x_min = [ x_min - purge_margin , x_min ] | min %}
	{% set y_min = [ y_min - purge_margin , y_min ] | min %}
	{% set x_min = [ x_min , axis_minimum_x ] | max %}
	{% set y_min = [ y_min , axis_minimum_y ] | max %}
	{% endif %}
	
	
	{% if verbose_enable == True %}
	
	{ action_respond_info("Smart Park location: {},{}.".format(
	(x_min),
	(y_min),
	)) }
	
	{% endif %}
	
	SAVE_GCODE_STATE NAME=Presmartpark_State
	
	G90
	{% if printer.toolhead.position.z < z_height %}
	G0 Z{z_height}
	{% endif %}
	G0 X{x_min} Y{y_min} F{travel_speed}
	G0 Z{z_height}
	
	RESTORE_GCODE_STATE NAME=Presmartpark_State

[gcode_macro _KAMP_Settings]
description = This macro contains all adjustable settings for KAMP
variable_verbose_enable = True
variable_mesh_margin = 0
variable_fuzz_amount = 0
variable_probe_dock_enable = True
variable_attach_macro = 'PROBE_OUT'
variable_detach_macro = 'PROBE_IN'
variable_purge_height = 0.8
variable_tip_distance = 3
variable_purge_margin = 10
variable_purge_amount = 30
variable_flow_rate = 10
variable_smart_park_height = 10
gcode = 
	
	{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}

[fcm]
topic = Alertas_M01

[mcu]
serial = /dev/ttyAMA0

[mcu rpi]
serial = /tmp/klipper_host_mcu

[printer]
kinematics = cartesian
max_velocity = 450
max_accel = 3500
max_z_velocity = 50
max_z_accel = 150

[adxl345]
cs_pin = rpi:None
spi_bus = spidev0.0

[resonance_tester]
accel_chip = adxl345
probe_points = 
	115, 115, 40

[input_shaper]
shaper_freq_x = 69
shaper_type_x = 2hump_ei
shaper_freq_y = 34.6
shaper_type_y = mzv

[skew_correction]

[exclude_object]

[gcode_arcs]
resolution = 0.1

[display]
lcd_type = ssd1306
i2c_mcu = rpi
i2c_bus = i2c.1
i2c_address = 60

[gcode_button button_pause]
pin = ^rpi:gpio27
press_gcode = PAUSE

[gcode_button button_play]
pin = ^rpi:gpio17
press_gcode = RESUME

[gcode_button button_cancel]
pin = ^rpi:gpio22
press_gcode = CANCEL_PRINT

[temperature_sensor raspberry_pi]
sensor_type = temperature_host
min_temp = 10
max_temp = 100

[filament_switch_sensor extruder_filament_sensor]
pause_on_runout = True
event_delay = 2.0
switch_pin = P1.24

[heater_bed]
heater_pin = P2.5
sensor_type = EPCOS 100K B57560G104F
sensor_pin = P0.23
min_temp = 10
max_temp = 130
control = pid
pid_kp = 66.889
pid_ki = 1.512
pid_kd = 739.954

[probe]
pin = ^P1.25
x_offset = 4
y_offset = 21
speed = 5.0
lift_speed = 15.0
sample_retract_dist = 1
samples = 4
samples_tolerance = 0.01
samples_result = median
samples_tolerance_retries = 3
z_offset = 5.549

[homing_override]
set_position_z = 0
gcode = 
	G90
	G1 Z10 F3000
	G28 X
	G28 Y
	PROBE_OUT
	G1 X117 Y117 F6000
	G28 Z
	_Z_TILT_ADJUST
	PROBE_IN

[bed_mesh]
speed = 120
horizontal_move_z = 10
mesh_min = 20, 20
mesh_max = 184, 200
probe_count = 4, 4
algorithm = bicubic
fade_start = 1
fade_end = 10
fade_target = 0

[screws_tilt_adjust]
screw1 = 24, 2
screw1_name = front left screw
screw2 = 24, 170
screw2_name = front right screw
screw3 = 198, 170
screw3_name = rear right screw
screw4 = 198, 37
screw4_name = rear left screw
horizontal_move_z = 10.
speed = 50.
screw_thread = CW-M4

[tmc2130 stepper_x]
cs_pin = P1.17
spi_software_sclk_pin = P0.4
spi_software_mosi_pin = P4.28
spi_software_miso_pin = P0.5
run_current = 0.8
stealthchop_threshold = 9999999

[stepper_x]
step_pin = P2.2
dir_pin = !P2.6
enable_pin = !P2.1
endstop_pin = P1.29
position_endstop = 0
position_min = 0
position_max = 245
homing_speed = 70
microsteps = 16
rotation_distance = 40

[tmc2130 stepper_y]
cs_pin = P1.15
spi_software_sclk_pin = P0.4
spi_software_mosi_pin = P4.28
spi_software_miso_pin = P0.5
run_current = 0.8
stealthchop_threshold = 999999

[stepper_y]
step_pin = P0.19
dir_pin = !P0.20
enable_pin = !P2.8
endstop_pin = P1.27
position_endstop = -18
position_min = -18
position_max = 219
homing_speed = 70
microsteps = 16
rotation_distance = 40

[tmc2130 stepper_z]
cs_pin = P1.10
spi_software_sclk_pin = P0.4
spi_software_mosi_pin = P4.28
spi_software_miso_pin = P0.5
run_current = 0.75
stealthchop_threshold = 999999

[stepper_z]
step_pin = P0.22
dir_pin = P2.11
enable_pin = !P0.21
endstop_pin = probe:z_virtual_endstop
position_min = -8
position_max = 250
microsteps = 16
rotation_distance = 8

[z_tilt]
z_positions = 
	
	
	-30, 117
	265, 117
points = 
	4, 96.5
	210, 96.5
speed = 100
horizontal_move_z = 15
retries = 10
retry_tolerance = 0.005

[tmc2130 stepper_z1]
cs_pin = P1.8
spi_software_sclk_pin = P0.4
spi_software_mosi_pin = P4.28
spi_software_miso_pin = P0.5
run_current = 0.75
stealthchop_threshold = 999999

[stepper_z1]
step_pin = P2.13
dir_pin = !P0.11
enable_pin = !P2.12
endstop_pin = probe:z_virtual_endstop
microsteps = 16
rotation_distance = 8

[extruder]
step_pin = P0.1
dir_pin = !P0.0
enable_pin = !P0.10
microsteps = 64
rotation_distance = 7.655
nozzle_diameter = 0.400
filament_diameter = 1.750
heater_pin = P2.7
sensor_type = EPCOS 100K B57560G104F
sensor_pin = P0.24
min_temp = 10
max_temp = 290
pressure_advance = 0
max_extrude_only_distance = 105
max_extrude_cross_section = 5
control = pid
pid_kp = 25.511
pid_ki = 1.260
pid_kd = 129.148

[fan]
pin = P2.3
off_below = 0.15
hardware_pwm = False
cycle_time = 0.0050
kick_start_time = 0.150

[heater_fan noozle_fan]
heater = extruder
heater_temp = 50
fan_speed = 1.0
pin = P2.4

[bed_mesh default-old]
version = 1
points = 
	-0.022079, 0.022088, 0.011254, 0.027088
	0.012921, 0.040421, -0.008746, -0.018746
	0.093754, 0.110421, 0.029588, 0.001254
	0.163754, 0.164588, 0.063754, 0.016254
min_x = 20.0
max_x = 183.97
min_y = 20.0
max_y = 200.0
x_count = 4
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = bicubic
tension = 0.2

[bed_mesh default-glass]
version = 1
points = 
	0.000833, 0.016667, 0.023333, 0.006667
	-0.005833, 0.020833, -0.001667, -0.035000
	0.048333, 0.052500, 0.000833, -0.075000
	0.061667, 0.064167, 0.026667, -0.053333
min_x = 20.0
max_x = 183.97
min_y = 20.0
max_y = 200.0
x_count = 4
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = bicubic
tension = 0.2

[bed_mesh default - NonGlass]
version = 1
points = 
	-0.036760, -0.065927, -0.185094, -0.310094
	0.074073, 0.348240, 0.306573, -0.021760
	0.164906, 0.391573, 0.324073, -0.094260
	0.124073, 0.049906, -0.080094, -0.450094
min_x = 20.0
max_x = 183.97
min_y = 20.0
max_y = 200.0
x_count = 4
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = bicubic
tension = 0.2

[bed_mesh default]
version = 1
points = 
	0.115316, 0.126566, 0.134066
	0.069066, 0.076566, 0.074066
	-0.025934, -0.009684, -0.008434
	-0.078434, -0.095934, -0.103434
x_count = 3
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = lagrange
tension = 0.2
min_x = 23.19
max_x = 65.19
min_y = 38.35
max_y = 169.34
=======================
Extruder max_extrude_ratio=2.078758
mcu 'mcu': Starting serial connect
webhooks client 1963210184: New connection
webhooks client 1963210184: Client info {'program': 'Moonraker', 'version': 'v0.8.0-343-g0f2e3d7'}
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
mcu 'mcu': Timeout on connect
MCU error during connect
Traceback (most recent call last):
  File "/home/m/klipper/klippy/mcu.py", line 791, in _mcu_identify
    self._serial.connect_uart(self._serialport, self._baud, rts)
  File "/home/m/klipper/klippy/serialhdl.py", line 183, in connect_uart
    self._error("Unable to connect")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Unable to connect

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/m/klipper/klippy/klippy.py", line 176, in _connect
    self.send_event("klippy:mcu_identify")
  File "/home/m/klipper/klippy/klippy.py", line 263, in send_event
    return [cb(*params) for cb in self.event_handlers.get(event, [])]
  File "/home/m/klipper/klippy/klippy.py", line 263, in <listcomp>
    return [cb(*params) for cb in self.event_handlers.get(event, [])]
  File "/home/m/klipper/klippy/mcu.py", line 796, in _mcu_identify
    raise error(str(e))
mcu.error: mcu 'mcu': Unable to connect
Build file /home/m/klipper/klippy/../.config(1427): Sat Apr  6 11:05:37 2024
========= Last MCU build config =========
# CONFIG_LOW_LEVEL_OPTIONS is not set
# CONFIG_MACH_AVR is not set
# CONFIG_MACH_ATSAM is not set
# CONFIG_MACH_ATSAMD is not set
CONFIG_MACH_LPC176X=y
# CONFIG_MACH_STM32 is not set
# CONFIG_MACH_HC32F460 is not set
# CONFIG_MACH_RP2040 is not set
# CONFIG_MACH_PRU is not set
# CONFIG_MACH_AR100 is not set
# CONFIG_MACH_LINUX is not set
# CONFIG_MACH_SIMU is not set
CONFIG_BOARD_DIRECTORY="lpc176x"
CONFIG_MCU="lpc1768"
CONFIG_CLOCK_FREQ=100000000
CONFIG_SERIAL=y
CONFIG_FLASH_SIZE=0x80000
CONFIG_FLASH_BOOT_ADDRESS=0x0
CONFIG_RAM_START=0x10000000
CONFIG_RAM_SIZE=0x7fe0
CONFIG_STACK_SIZE=512
CONFIG_FLASH_APPLICATION_ADDRESS=0x4000
CONFIG_LPC_SELECT=y
CONFIG_MACH_LPC1768=y
# CONFIG_MACH_LPC1769 is not set
CONFIG_LPC_FLASH_START_4000=y
# CONFIG_LPC_FLASH_START_0000 is not set
# CONFIG_LPC_USB is not set
CONFIG_LPC_SERIAL_UART0_P03_P02=y
CONFIG_SERIAL_BAUD=250000
CONFIG_USB_VENDOR_ID=0x1d50
CONFIG_USB_DEVICE_ID=0x614e
CONFIG_USB_SERIAL_NUMBER="12345"
CONFIG_WANT_GPIO_BITBANGING=y
CONFIG_WANT_DISPLAYS=y
CONFIG_WANT_SENSORS=y
CONFIG_WANT_LIS2DW=y
CONFIG_WANT_SOFTWARE_I2C=y
CONFIG_WANT_SOFTWARE_SPI=y
CONFIG_NEED_SENSOR_BULK=y
CONFIG_CANBUS_FREQUENCY=1000000
CONFIG_HAVE_GPIO=y
CONFIG_HAVE_GPIO_ADC=y
CONFIG_HAVE_GPIO_SPI=y
CONFIG_HAVE_GPIO_I2C=y
CONFIG_HAVE_GPIO_HARD_PWM=y
CONFIG_HAVE_STRICT_TIMING=y
CONFIG_HAVE_CHIPID=y
CONFIG_HAVE_STEPPER_BOTH_EDGE=y
CONFIG_HAVE_BOOTLOADER_REQUEST=y
CONFIG_INLINE_STEPPER_HACK=y
=======================
Build file /home/m/klipper/klippy/../out/klipper.dict(7495): Sat Apr  6 11:06:00 2024
Last MCU build version: v0.12.0-143-g01c7befa
Last MCU build tools: gcc: (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revision 273027] binutils: (2.34-4+rpi1+14) 2.34
Last MCU build config: ADC_MAX=4095 BUS_PINS_i2c0=P0.28,P0.27 BUS_PINS_i2c1=P0.1,P0.0 BUS_PINS_i2c1a=P0.20,P0.19 BUS_PINS_i2c2=P0.11,P0.10 BUS_PINS_ssp0=P0.17,P0.18,P0.15 BUS_PINS_ssp1=P0.8,P0.9,P0.7 CLOCK_FREQ=100000000 MCU=lpc1768 PWM_MAX=255 RECEIVE_WINDOW=192 RESERVE_PINS_serial=P0.3,P0.2 SERIAL_BAUD=250000 STATS_SUMSQ_BASE=256 STEPPER_BOTH_EDGE=1
Build file /home/m/klipper/klippy/../out/klipper.elf(595688): Sat Apr  6 11:06:10 2024
mcu 'mcu': Wait for identify_response
Traceback (most recent call last):
  File "/home/m/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/m/klipper/klippy/serialhdl.py", line 262, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/m/klipper/klippy/serialhdl.py", line 319, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/m/klipper/klippy/serialhdl.py", line 254, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/m/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Serial connection closed
